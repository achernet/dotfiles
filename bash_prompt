# Disable variable expansion in prompt strings.
shopt -u promptvars

# If the terminal supports ANSI color escape sequences, cache them for future
# use. It would be better to use tput here, but it's sadly absent on Cygwin,
# and probably other platforms, too. Anyway, we only use a few basic escape
# sequences, so this shouldn't hurt. Hopefully.
if grep -E '^(cygwin|linux|xterm)-?' <<<"$TERM" >/dev/null 2>&1; then
  _bash_prompt_term_reset=$'\033[m'
  
  _bash_prompt_term_bold=$'\033[1m'
  
  _bash_prompt_term_red=$'\033[31m'
  _bash_prompt_term_green=$'\033[32m'
  _bash_prompt_term_yellow=$'\033[33m'
  _bash_prompt_term_blue=$'\033[34m'
  _bash_prompt_term_magenta=$'\033[35m'
  _bash_prompt_term_cyan=$'\033[36m'
  _bash_prompt_term_white=$'\033[37m'
fi

# Set a flag if the system supports ACPI and has a battery.
if type acpi >/dev/null 2>&1 && acpi | grep Battery >/dev/null 2>&1; then
  _bash_prompt_have_battery=1
fi

# Set a flag if the system has an uptime command. (Cygwin does not have one in
# its default configuration.)
if type uptime >/dev/null 2>&1; then
  _bash_prompt_have_uptime=1
fi

# Count the number of processors in the system and save it for use in CPU load
# calculation.
#
# Processor detection currently relies on /proc/cpuinfo, so it
# only works properly on Linux. Kudos to anyone who suggests a more portable
# way of doing this.
if [ -f /proc/cpuinfo ]; then
  _bash_prompt_cpu_count=$(grep -c '^processor[[:space:]]*:' /proc/cpuinfo)
else
  _bash_prompt_cpu_count=1
fi

preexec () {
  local cmd_line job_spec real_cmd
  
  # Split the command line into multiple words.
  read -a cmd_line <<<"$1"
  
  # Find job specification.
  case "${cmd_line[0]}" in
    fg) [ -n "${cmd_line[1]}" ] && job_spec=${cmd_line[1]} || job_spec=%% ;;
    %*) job_spec=${cmd_line[0]} ;;
  esac
  
  # Get real command line.
  if [ -n "$job_spec" ] && jobs "$job_spec" 2>/dev/null; then
    real_cmd=$(jobs "$job_spec" | sed 's/[^ ]* *[^ ]* *\(.*\)/\1/')
  else
    real_cmd=$1
  fi
  
  # Set the terminal title.
  _bash_prompt_title "$real_cmd"
}

precmd () {
  # Reset prompt variables.
  _bash_prompt_line=0
  _bash_prompt_col=0
  PS1=
  PS2='> '
  PS3='#? '
  PS4='+ '
  
  # Build the prompt.
  _bash_prompt_ps1_escape "$_bash_prompt_term_bold"
  _bash_prompt_ps1_build_machine
  _bash_prompt_ps1_append ' '
  _bash_prompt_ps1_build_status
  _bash_prompt_ps1_append ' '
  _bash_prompt_ps1_build_directory
  _bash_prompt_ps1_append $'\n'
  _bash_prompt_ps1_build_symbol
  _bash_prompt_ps1_escape "$_bash_prompt_term_reset"
  _bash_prompt_ps1_escape "$(_bash_prompt_title)"
}

_bash_prompt_ps1_build_machine () {
  _bash_prompt_ps1_escape "$_bash_prompt_term_cyan"
  _bash_prompt_ps1_append "$USER"
  _bash_prompt_ps1_escape "$_bash_prompt_term_white"
  _bash_prompt_ps1_append @
  _bash_prompt_ps1_escape "$_bash_prompt_term_magenta"
  _bash_prompt_ps1_append "$HOSTNAME"
}

_bash_prompt_ps1_build_status () {
  _bash_prompt_ps1_escape "$_bash_prompt_term_white"
  _bash_prompt_ps1_build_battery && _bash_prompt_ps1_append '|'
  _bash_prompt_ps1_build_load && _bash_prompt_ps1_append '|'
  _bash_prompt_ps1_build_jobs
}

_bash_prompt_ps1_build_battery () {
  if [ -n "$_bash_prompt_have_battery" ]; then
    local charge=$(acpi | sed 's/.*, \([[:digit:]]\{1,\}\)%.*/\1/')
    
    _bash_prompt_ps1_append B:
    
    if [ "$charge" -ge 90 ]; then
      _bash_prompt_ps1_escape "$_bash_prompt_term_green"
    elif [ "$charge" -ge 45 ]; then
      _bash_prompt_ps1_escape "$_bash_prompt_term_yellow"
    else
      _bash_prompt_ps1_escape "$_bash_prompt_term_red"
    fi
    
    _bash_prompt_ps1_append "$charge%"
    
    _bash_prompt_ps1_escape "$_bash_prompt_term_white"
    
    return 0
  else
    return 1
  fi
}

_bash_prompt_ps1_build_load () {
  if [ -n "$_bash_prompt_have_uptime" ]; then
    local load=$(uptime | sed 's/.*: \([[:digit:].]*\).*/\1/')
    local load_int=${load/./}
    
    _bash_prompt_ps1_append L:
    
    if [ "$load_int" -lt $((_bash_prompt_cpu_count*50)) ]; then
      _bash_prompt_ps1_escape "$_bash_prompt_term_green"
    elif [ "$load_int" -lt $((_bash_prompt_cpu_count*100)) ]; then
      _bash_prompt_ps1_escape "$_bash_prompt_term_yellow"
    else
      _bash_prompt_ps1_escape "$_bash_prompt_term_red"
    fi
    
    _bash_prompt_ps1_append "$load"
    
    _bash_prompt_ps1_escape "$_bash_prompt_term_white"
    
    return 0
  else
    return 1
  fi
}

_bash_prompt_ps1_build_jobs () {
  local count=$(jobs | wc -l)
  
  _bash_prompt_ps1_append J:
  
  if [ "$count" -eq 0 ]; then
    _bash_prompt_ps1_escape "$_bash_prompt_term_green"
  elif [ "$count" -eq 1 ]; then
    _bash_prompt_ps1_escape "$_bash_prompt_term_yellow"
  else
    _bash_prompt_ps1_escape "$_bash_prompt_term_red"
  fi
  
  _bash_prompt_ps1_append "$count"
  
  _bash_prompt_ps1_escape "$_bash_prompt_term_white"
  
  return 0
}

_bash_prompt_ps1_build_directory () {
  _bash_prompt_ps1_escape "$_bash_prompt_term_blue"
  _bash_prompt_ps1_append "$(_bash_prompt_truncate "${PWD/#$HOME/~}" \
                           $((COLUMNS-_bash_prompt_col)) left)"
}

_bash_prompt_ps1_build_symbol () {
  _bash_prompt_ps1_escape "$_bash_prompt_term_white"
  if [ "$UID" -eq 0 ]; then
    _bash_prompt_ps1_append '# '
  else
    _bash_prompt_ps1_append '$ '
  fi
}

# _bash_prompt_ps1_append STRING
# 
# Append STRING to PS1. Backslashes will be doubled to ensure proper display.
# $_bash_prompt_line and $_bash_prompt_col will be updated as appropriate.
_bash_prompt_ps1_append () {
  local i; for ((i=0;i<${#1};++i)); do
    if [ "${1:i:1}" = $'\n' ]; then
      let ++_bash_prompt_line
      _bash_prompt_col=0
    else
      let ++_bash_prompt_col
    fi
  done
  
  PS1=$PS1${1//\\/\\\\}
}

# _bash_prompt_ps1_escape STRING
# 
# Append STRING to PS1. Backslashes will be doubled to ensure proper display.
# \[ and \] markers will be added to mark the string as an escape sequence.
# $_bash_prompt_line and $_bash_prompt_col will not be updated.
_bash_prompt_ps1_escape () {
  PS1=$PS1\\[${1//\\/\\\\}\\]
}

# _bash_prompt_title [COMMAND]
# 
# Output an escape sequence to set the terminal's title bar. Only works on
# xterm-like terminals. If COMMAND is not provided, the name of the currently-
# executing shell will be substituted.
_bash_prompt_title () {
  if grep -E '^(cygwin|xterm)-?' <<<"$TERM" >/dev/null 2>&1; then
    printf '\033]0;%s\a' "${1:-$0} - $USER@$HOSTNAME:${PWD/#$HOME/~}"
  fi
}

# _bash_prompt_truncate STRING LENGTH [MODE]
#
# Output STRING truncated to LENGTH characters. MODE, which may be "right"
# (the default) or "left", controls which side of the string to truncate on.
_bash_prompt_truncate () {
  if [ ${#1} -le "$2" ]; then
    printf %s "$1"
  elif [ "$3" = left ]; then
    printf %s "...${1:3-$2}"
  else
    printf %s "${1:0:$2-3}..."
  fi
}
